#   -*- mode: org; fill-column: 60 -*-

#+TITLE: Workflow
#+STARTUP: showall
#+TOC: headlines 4
#+PROPERTY: filename

[[https://img.shields.io/badge/made%20by-Chenla%20Institute-999999.svg?style=flat-square]] 
[[https://img.shields.io/badge/class-primer-56B4E9.svg?style=flat-square]]
[[https://img.shields.io/badge/type-work-0072B2.svg?style=flat-square]]
[[https://img.shields.io/badge/status-wip-D55E00.svg?style=flat-square]]
[[https://img.shields.io/badge/licence-MIT%2FCC%20BY--SA%204.0-000000.svg?style=flat-square]]

bibliography:~/proj/chenla/hoard/bib.bib

* Workflow
:PROPERTIES:
:CUSTOM_ID:
:Name:     /home/deerpig/proj/chenla/warp/ww-workflow.org
:Created:  2018-04-01T19:12@Prek Leap (11.642600N-104.919210W)
:ID:       781acb41-12b6-4bba-bdb3-51c90bf961e3
:VER:      575856815.708964449
:GEO:      48P-491193-1287029-15
:BXID:     proj:EXK2-4528
:Class:    primer
:Type:     work
:Status:   wip
:Licence:  MIT/CC BY-SA 4.0
:END:

** TL;DR

There is workflow for a person, for a group and for system
processes.  The last may sound strange but I think this is
the right way of thinking about it.

If a Pattern Language is a concept and a Primer is a expression
then the hoard is an instance.

The Primer is the DNA, and the Hoard is the translation of
the DNA by RNA into proteins that actually build stuff.

---

Feedback and test between steps -> this is far more
important than almost anything else.  The better you can
test and know when something is finished, and even better
the quality of something when it is finished is the
difference between an assembly line and a master craftsman.
We need to bake that into automated processes so that they
not only can test but learn how to improve and that means
dealing with ambiguity.

The more feedback loops built into processes the better, and
that means that processes need to be designed to be able to
continually add additional feedback loops that pass feedback
to higher layers of abstraction.

The other important thing that needs to be built in is that
you need to be able to improve things potentially at every
step of a running process, it is part of the REPL, not
something done outside and added to the process.  Code today
is written outside of the running process but when a
craftsman is making something, he looks to see how to
improve the process and what he makes as he makes or
composes.  This is what is missing from industrial workflows
and toolchains. and this means that feedback loops need
multiple higher layers of pattern recognition to learn to
tweak themselves as they work.

---

This is critically important if the MIDDLE is to be able to
do the job envisioned -- it needs to be a highly distributed
ML system generated bottom up from very flexible and
fine-grained iterative self-improving feeback loops.  In
effect we need a system that is constantly intentionally
practicing it's craft.  It also needs to know when it
doesn't understand and ask questions, and not necessarily
take the answers literally, but weave them into the process
-- answers are not the same as directives.

** Table of Contents
 - Workflow
   - step based procedural process 
 - Tools
   - dynamic, extensible, self-documenting
   - a tool does one thing -> some things that are called
     tools are actually toolchains packaged as tools such as
     word processers.
 - Toolchains
   - Steps and Pipes
   - Feedback and in-process self-improvement
 - Composition
   - process of writing, design, research
   - iteration by approximation
 - Rollback -> Reversibility
 - Documentation
 - History
