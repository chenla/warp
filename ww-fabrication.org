#   -*- mode: org; fill-column: 60 -*-

#+TITLE: Fabrication
#+STARTUP: showall
#+TOC: headlines 4
#+PROPERTY: filename

[[https://img.shields.io/badge/made%20by-Chenla%20Institute-999999.svg?style=flat-square]] 
[[https://img.shields.io/badge/class-primer-56B4E9.svg?style=flat-square]]
[[https://img.shields.io/badge/type-work-0072B2.svg?style=flat-square]]
[[https://img.shields.io/badge/status-wip-D55E00.svg?style=flat-square]]
[[https://img.shields.io/badge/licence-MIT%2FCC%20BY--SA%204.0-000000.svg?style=flat-square]]

bibliography:../hoard/bib.bib

* Fabrication
:PROPERTIES:
:CUSTOM_ID:
:Name:     /home/deerpig/proj/chenla/warp/ww-fabrication.org
:Created:  2018-04-16T12:31@Prek Leap (11.642600N-104.919210W)
:ID:       f67b6411-1e2b-4fe7-a4b9-aa5543da2118
:VER:      577128773.320555408
:GEO:      48P-491193-1287029-15
:BXID:     proj:DFG1-2416
:Class:    primer
:Type:     work
:Status:   wip
:Licence:  MIT/CC BY-SA 4.0
:END:

** TL;DR

I originally was going to call this part 'Development' or perhaps
'Methodology" but neither felt right.  They are too fixed and formal
and don't match the process that I want to convey.

Fabrication is an iterative bottom up process that fits better with
the Way than our traditional notions of development and haywire
dogmatic methodologies like Agile and Scrum.  Traditional industrial
processes result in workflows that are industrial and run counter to
our example of a bird building a nest.

Industrial methodologies are designed to produce exact duplicates of
things.  In fact, if there is a variation between copies, the
variation is discarded, even if that variation is an improvement.
This is, on the face of it, insane.  And be have become trained to see
variation as bad, as an error, a mutation that has to be eliminated.

In the early days of Dell computer, it was well known that Dell
actually made changes to running production lines that produced
computers that evolved as the designs were coming off the assembly
line.  I can't say if this was good or bad.  It was frustrating at
times when something broke, because you might open two computers of
the same model side by side and see that things were somewhat
different between the two.  At the time I thought that this was a bad
thing.  But I'm coming round to the idea that I was the one that
should have been looking at which version was better than the other
and perhaps in fixing the other box, to incorporate the better design
into the older one.  Of course the entire infrastructure for computer
manufacture and maintainance made this nearly impossible.

But this has to be our goal -- to rethink fabrication, production,
deployment and repair as a more fluid and flexible system, that allows
us to take a more birdlike approach to building things.

Our factory tooling, outsourcing of sub-assemblies, and pretty much
everything else from repair and customer support, to the way that we
sell things in the show room, and how we purchase things and decide
what to buy.  Perhaps when buying a washing machine we should be
looking at a litter of machines of the same model that are in the
store, look at each, and as we would choose a puppy from a litter,
look at the difference between them and go with the one that feels
right to you.

To make this possible we need fresh eyes and approaches to all stages
of design, production, deployment, upgrading and repair.

Microsoft, for all of their faults (which are legion) has been very
good at maintaining backward compatibility for running applications at
the OS level.  They had terrible reputation for backward and forward
compatibility for file formats.  But this wasn't so much a bug as a
feature to force people to upgrade their software and pay more money.
In the 1990's is was common if you had a copy of English Word, that it
would not open word files created in Japanese Word, even if the
document used no Japanese characters at all.


** Table of Contents


  - Succession- pioneer stage
      - sparse nodes, like early Internet
      - dummy nodes
      - surrogate nodes
    - intermediate stages
    - mature stage
  - Niche
  - Development
    - identify problem or need 
    - imagine solution form hypothesis
    - collect patterns
    - form language
    - identify inputs, side effects and desired outputs
    - end of life, and recycling/repurposing as input to
      other niches and processes
    - process start and end points
    - break into steps
    - feedback mechanisms
    - rules and process logic
  - Build
    - build model, test scenarios
    - build prototype - alpha
    - build beta and try in production
    - build release candidate put into production
  - Deployment
    - collect feedback, fix bugs
    - identify new features
    - loop add features, test, release 
    - when something breaks roll back
    - monitor feedback for maintain and management --
      anticipate failures
  - Iteration
  - Running Processes
    - when stable, replicate while developing new features and fixes
